{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u043a\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u043f\u043e UDP: import socket HOST = 'localhost' PORT = 8081 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((HOST, PORT)) \u041f\u0430\u043a\u0443\u0435\u043c \u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u0442\u0432\u0435\u0442 \u043e\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: message = 'Hello server!' s.sendto(message.encode('utf-8'), (HOST, PORT)) data = s.recv(1024) print('Received: ' + data.decode('utf-8')) s.close() \u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u043a\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043f\u043e UDP: import socket import sys HOST = 'localhost' PORT = 8081 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) try: s.bind((HOST, PORT)) except socket.error as msg: print('Error Code : ' + str(msg[0]) + ' Message ' + msg[1]) \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 while True: data, addr = s.recvfrom(1024) print('Received: ' + data.decode('utf-8')) message = 'Hello, client!' s.sendto(message.encode('utf-8'), addr) \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 \u041b\u043e\u0433\u0438\u043a\u0430 \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0441\u0442\u043e\u0440\u043e\u043d \u043f\u043e \u0442\u0435\u043e\u0440\u0435\u043c\u0435 \u041f\u0438\u0444\u0430\u0433\u043e\u0440\u0430 \u0438 \u0432\u0430\u043b\u0438\u0434\u0430\u0446\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043a\u043b\u0438\u0435\u043d\u0442\u0430: def LocateCalculate(data): if data[2] == 0: return (data[0] ** 2 + data[1] ** 2) ** 0.5 elif data[1] == 0: return (data[2] ** 2 - data[0] ** 2) ** 0.5 return (data[2] ** 2 - data[1] ** 2) ** 0.5 def CheckMessage(data): try: val_tuple = tuple(map(int, data.split())) except ValueError: print('Something went wrong with input') return False for i in val_tuple: if i < 0: print('Sides can not be negative') return False if (val_tuple[2] <= val_tuple[1] or val_tuple[2] <= val_tuple[0]) and val_tuple[2] != 0: print('Hypothenus can not be shorter than cathetus') return False return val_tuple \u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u043a\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u043f\u043e TCP: import socket message = input() HOST = 'localhost' PORT = 8081 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) \u041b\u043e\u0433\u0438\u043a\u0430 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0438 \u043f\u0440\u0438\u0435\u043c\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439: s.sendall(message.encode('utf-8')) data = s.recv(1024) print(data.decode('utf-8')) data = s.recv(1024) print(data.decode('utf-8')) s.close() \u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u043a\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043f\u043e TCP: import socket import sys from func import LocateCalculate, CheckMessage HOST = 'localhost' PORT = 8081 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: s.bind((HOST, PORT)) except socket.error as msg: print('Error Code : ' + str(msg[0]) + ' Message ' + msg[1]) s.listen(10) \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f: while True: conn, addr = s.accept() print('Connected with ' + addr[0] + ':' + str(addr[1])) data = conn.recv(1024) reply = data.decode('utf-8') message = 'Pythagorator 3000k\\nInsert data like \"leg leg hypothenus\" using space as separator, mark unknown as \"0\", e.g. 0 3 25' conn.sendall(message.encode('utf-8')) temp = CheckMessage(reply) if temp: msg = f\"The input is: {reply}\\nX = {LocateCalculate(temp)}\" conn.sendto(msg.encode('utf-8'), addr) print(f\"sent to {addr}\") conn.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 3 \u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u043e\u043a\u0435\u0442\u0430 \u0432\u0437\u044f\u0442\u0430 \u0438\u0437 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e \u0443\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u044f \u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0437\u0430\u043f\u0440\u043e\u0441 \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440, \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u0442\u0432\u0435\u0442: request = 'GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n' s.sendall(request.encode()) data = s.recv(1024) print(data.decode('utf-8')) s.close() \u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u043e\u043a\u0435\u0442\u0430 \u0432\u0437\u044f\u0442\u0430 \u0438\u0437 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e \u0443\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u044f \u0427\u0438\u0442\u0430\u0435\u043c \u0444\u0430\u0439\u043b \u043f\u043e\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u043e\u043c Python: with open('index.html', 'r') as f: file = f.read() \u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0444\u0430\u0439\u043b \u043a\u0430\u0436\u0434\u043e\u043c\u0443 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u043e\u043c\u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e: while True: conn, addr = s.accept() print('Connected with ' + addr[0] + ':' + str(addr[1])) conn.sendto(file.encode('utf-8'), addr) data = conn.recv(1024) conn.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 4 \u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f: def WaitForMessage(conn): while True: try: data = conn.recv(1024) if data: print(data.decode('utf-8')) except: break conn.close() \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: message = 1 while message: th = threading.Thread(target=WaitForMessage, args=(s,)) th.start() message = input() s.sendall(message.encode('utf-8')) s.close() \u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0438 \u043c\u0430\u0441\u0441\u043e\u0432\u043e\u0439 \u0440\u0430\u0441\u0441\u044b\u043b\u043a\u0438, \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0438 \u044d\u043c\u043e\u0434\u0437\u0438 \u0438 \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f: def Emojify(addr): emoji = b\"\\\\\" + f\"U0001F{addr % 1000}\".encode() return emoji.decode('unicode_escape') def SendToAll(msg): for i in clients: i.send(msg) def WaitForMessage(addr, conn): clients.append(conn) while True: try: data = conn.recv(1024) code = Emojify(addr[1]) message = f\"\\n[{addr[1]}] {code} says: {data.decode('utf-8')}\" SendToAll(message.encode('utf-8')) except: clients.remove(conn) SendToAll(f\"{code} Disconnected\".encode('utf-8')) break conn.close() \u041d\u0435\u043f\u043e\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0435\u043d\u043d\u043e \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043b\u0443\u043f: s.listen(10) while True: conn, addr = s.accept() print('Connected with ' + addr[0] + ':' + str(addr[1])) th = threading.Thread(target=WaitForMessage, args=(addr, conn)) th.start() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 5 \u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0438\u0437 \u043f\u0440\u043e\u0448\u043b\u043e\u0433\u043e \u0437\u0430\u0434\u0430\u043d\u0438\u044f, \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u043c \u0437\u0430\u0434\u0430\u043d\u0438\u044f\u043c \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0438 \u0441\u043e\u043a\u0435\u0442. \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0433\u043e \u043b\u0443\u043f\u0430 \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: header = b'POST /subject HTTP/1.1\\r\\nHost: localhost\\r\\nAccept: text/html\\r\\nContent-Type: application/json\\r\\n' # \u0442\u0435\u043c\u043f\u043b\u0435\u0439\u0442 message = 1 while message: th = threading.Thread(target=WaitForMessage, args=(s,)) th.start() key = input('\u0414\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430: ') # \u0436\u0434\u0435\u043c \u0432\u0432\u043e\u0434\u0430 \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0430 \u0438 \u043e\u0446\u0435\u043d\u043a\u0438 value = input('\u041e\u0446\u0435\u043d\u043a\u0430: ') son_of_j = json.dumps({key: value}) # \u0441\u043e\u0437\u0434\u0430\u0435\u043c json request = header + f\"Content-Length: {len(son_of_j)}\\r\\n\\r\\n\".encode() + json.dumps({key: value}).encode('utf-8') s.send(request) s.close() \u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u041a\u043b\u0430\u0441\u0441 Response: class Response: def __init__(self, status, reason, headers=None, body=None): self.status = status self.reason = reason self.headers = headers self.body = body def return_string(self): return f\"{self.status} {self.reason} {self.body}\" \u041a\u043b\u0430\u0441\u0441 Request: class Request: def __init__(self, method, target, version, headers, rfile, conn): self.method = method self.target = target self.version = version self.headers = headers self.rfile = rfile self.conn = conn @property def path(self): return self.url.path @property @lru_cache(maxsize=None) def query(self): return parse_qs(self.url.query) @property @lru_cache(maxsize=None) def url(self): return urlparse(self.target) def body(self): size = self.headers.get('Content-Length') if not size: return None return self.rfile.read(size) \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0438 \u043e\u0431\u0441\u043b\u0443\u0436\u0438\u0432\u0430\u043d\u0438\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: class HTTPserver(): def __init__(self, host, port, server_name): self._host = host self._port = port self._server_name = server_name def init_socket(self): self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: self.socket.bind((self._host, self._port)) self.socket.listen(10) except socket.error as msg: print('Error Code : ' + str(msg[0]) + ' Message ' + msg[1]) def launch_server(self): self.init_socket() while True: conn, addr = self.socket.accept() print('Connected with ' + addr[0] + ':' + str(addr[1])) th = threading.Thread(target=self.serve_client, args=(conn,)) th.start() def serve_client(self, conn): while True: req = self.parse_request(conn) resp = self.handle_request(req) conn.send(resp.return_string().encode()) with open('AcademicPerformance.html') as html: conn.send(html.read().encode()) # sending html conn.close() \u041f\u0430\u0440\u0441\u0435\u0440\u044b (\u043c\u0435\u0442\u043e\u0434\u044b \u0432\u043d\u0443\u0442\u0440\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 HTTPserver): def parse_request(self, conn): rfile = conn.makefile('rb') method, target, ver = self.parse_request_line(rfile) headers = self.parse_headers(rfile) return Request(method, target, ver, headers, rfile, conn) def parse_request_line(self, rfile): raw = rfile.readline(MAX_LINE + 1) if len(raw) > MAX_LINE: raise HTTPError(400, 'Bad request', 'Request line is too long') req_line = str(raw, 'iso-8859-1') print(req_line) words = req_line.split() if len(words) != 3: raise HTTPError(400, 'Bad request', 'Malformed request line') method, target, ver = words if ver != 'HTTP/1.1': raise HTTPError(505, 'HTTP Version Not Supported') return method, target, ver def parse_headers(self, rfile): headers = [] while True: line = rfile.readline(MAX_LINE + 1) if len(line) > MAX_LINE: raise HTTPError(494, 'Request header too large') if line in (b'\\r\\n', b'\\n', b''): break headers.append(line) if len(headers) > MAX_HEADERS: raise HTTPError(494, 'Too many headers') sheaders = b''.join(headers).decode('iso-8859-1') return Parser().parsestr(sheaders) def handle_request(self, req): # \u0440\u0435\u0448\u0430\u0435\u043c \u043a\u0442\u043e \u043f\u043e\u0441\u0442, \u043a\u0442\u043e \u0433\u0435\u0442 if req.path == '/subject' and req.method == 'POST': return self.handle_post(req) if req.path == '/subject' and req.method == 'GET': return self.handle_get(req) \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 JSON \u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435\u043c \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b: def handle_post(self, req): # \u0443\u0441\u043f\u043e\u043a\u0430\u0438\u0432\u0430\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f, \u0447\u0442\u043e \u043c\u044b \u0432\u0441\u0435 \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u043b\u0438 content_type = req.headers.get('Content-Type') accept = req.headers.get('Accept') if ('text/html' in accept) and ('application/json' in content_type): # \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 accept \u0438 content-type contentType = 'text/html; charset=utf-8' body = 'I can read your request' son_of_j = self.ExtractJson(req) try: self.CombineAndSave(son_of_j) except: return Response(500, 'Internal server error') else: return Response(406, 'Not Acceptable') body = body.encode('utf-8') headers = [('Content-Type', contentType), ('Content-Length', len(body))] return Response(200, 'OK', headers, body) def CombineAndSave(self, d): with open('data.json', mode='r', encoding='utf-8') as f: data = json.load(f) for i in d.keys(): # \u0441\u043e\u0432\u043c\u0435\u0449\u0430\u0435\u043c json \u0444\u0430\u0439\u043b\u044b data[i] = data.get(i, []) data[i].append(d[i]) with open('data.json', mode='w', encoding='utf-8') as f: # \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0438\u0442\u043e\u0433\u043e\u0432\u044b\u0439 json json.dump(data, f) data = json2html.convert(json=data) with open('AcademicPerformance.html', 'w') as htmlfile: # \u0441\u043e\u0437\u0434\u0430\u0435\u043c html \u0438\u0437 json htmlfile.write(str(data)) def ExtractJson(self, req): # \u0432\u044b\u0442\u0430\u0441\u043a\u0438\u0432\u0430\u0435\u043c \u043a\u043e\u043d\u0442\u0435\u043d\u0442 \u0438\u0437 \u0440\u0435\u043a\u0432\u0435\u0441\u0442\u0430 json_str = req.rfile.readline(int(req.headers.get('Content-Length'))) return json.loads(json_str) \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0438 \u0437\u0430\u043f\u0443\u0441\u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0430: a = HTTPserver('localhost', 8081, 'Server') a.launch_server()","title":"Home"},{"location":"#1","text":"","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"#_1","text":"\u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u043a\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u043f\u043e UDP: import socket HOST = 'localhost' PORT = 8081 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((HOST, PORT)) \u041f\u0430\u043a\u0443\u0435\u043c \u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u0442\u0432\u0435\u0442 \u043e\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: message = 'Hello server!' s.sendto(message.encode('utf-8'), (HOST, PORT)) data = s.recv(1024) print('Received: ' + data.decode('utf-8')) s.close()","title":"\u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0430\u044f \u0447\u0430\u0441\u0442\u044c"},{"location":"#_2","text":"\u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u043a\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043f\u043e UDP: import socket import sys HOST = 'localhost' PORT = 8081 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) try: s.bind((HOST, PORT)) except socket.error as msg: print('Error Code : ' + str(msg[0]) + ' Message ' + msg[1]) \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 while True: data, addr = s.recvfrom(1024) print('Received: ' + data.decode('utf-8')) message = 'Hello, client!' s.sendto(message.encode('utf-8'), addr)","title":"\u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c"},{"location":"#2","text":"\u041b\u043e\u0433\u0438\u043a\u0430 \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0441\u0442\u043e\u0440\u043e\u043d \u043f\u043e \u0442\u0435\u043e\u0440\u0435\u043c\u0435 \u041f\u0438\u0444\u0430\u0433\u043e\u0440\u0430 \u0438 \u0432\u0430\u043b\u0438\u0434\u0430\u0446\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043a\u043b\u0438\u0435\u043d\u0442\u0430: def LocateCalculate(data): if data[2] == 0: return (data[0] ** 2 + data[1] ** 2) ** 0.5 elif data[1] == 0: return (data[2] ** 2 - data[0] ** 2) ** 0.5 return (data[2] ** 2 - data[1] ** 2) ** 0.5 def CheckMessage(data): try: val_tuple = tuple(map(int, data.split())) except ValueError: print('Something went wrong with input') return False for i in val_tuple: if i < 0: print('Sides can not be negative') return False if (val_tuple[2] <= val_tuple[1] or val_tuple[2] <= val_tuple[0]) and val_tuple[2] != 0: print('Hypothenus can not be shorter than cathetus') return False return val_tuple","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2"},{"location":"#_3","text":"\u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u043a\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u043f\u043e TCP: import socket message = input() HOST = 'localhost' PORT = 8081 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) \u041b\u043e\u0433\u0438\u043a\u0430 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0438 \u043f\u0440\u0438\u0435\u043c\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439: s.sendall(message.encode('utf-8')) data = s.recv(1024) print(data.decode('utf-8')) data = s.recv(1024) print(data.decode('utf-8')) s.close()","title":"\u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0430\u044f \u0447\u0430\u0441\u0442\u044c"},{"location":"#_4","text":"\u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u043a\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043f\u043e TCP: import socket import sys from func import LocateCalculate, CheckMessage HOST = 'localhost' PORT = 8081 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: s.bind((HOST, PORT)) except socket.error as msg: print('Error Code : ' + str(msg[0]) + ' Message ' + msg[1]) s.listen(10) \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f: while True: conn, addr = s.accept() print('Connected with ' + addr[0] + ':' + str(addr[1])) data = conn.recv(1024) reply = data.decode('utf-8') message = 'Pythagorator 3000k\\nInsert data like \"leg leg hypothenus\" using space as separator, mark unknown as \"0\", e.g. 0 3 25' conn.sendall(message.encode('utf-8')) temp = CheckMessage(reply) if temp: msg = f\"The input is: {reply}\\nX = {LocateCalculate(temp)}\" conn.sendto(msg.encode('utf-8'), addr) print(f\"sent to {addr}\") conn.close()","title":"\u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c"},{"location":"#3","text":"","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3"},{"location":"#_5","text":"\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u043e\u043a\u0435\u0442\u0430 \u0432\u0437\u044f\u0442\u0430 \u0438\u0437 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e \u0443\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u044f \u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0437\u0430\u043f\u0440\u043e\u0441 \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440, \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u0442\u0432\u0435\u0442: request = 'GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n' s.sendall(request.encode()) data = s.recv(1024) print(data.decode('utf-8')) s.close()","title":"\u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0430\u044f \u0447\u0430\u0441\u0442\u044c"},{"location":"#_6","text":"\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u043e\u043a\u0435\u0442\u0430 \u0432\u0437\u044f\u0442\u0430 \u0438\u0437 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e \u0443\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u044f \u0427\u0438\u0442\u0430\u0435\u043c \u0444\u0430\u0439\u043b \u043f\u043e\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u043e\u043c Python: with open('index.html', 'r') as f: file = f.read() \u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0444\u0430\u0439\u043b \u043a\u0430\u0436\u0434\u043e\u043c\u0443 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u043e\u043c\u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e: while True: conn, addr = s.accept() print('Connected with ' + addr[0] + ':' + str(addr[1])) conn.sendto(file.encode('utf-8'), addr) data = conn.recv(1024) conn.close()","title":"\u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c"},{"location":"#4","text":"","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4"},{"location":"#_7","text":"\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f: def WaitForMessage(conn): while True: try: data = conn.recv(1024) if data: print(data.decode('utf-8')) except: break conn.close() \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: message = 1 while message: th = threading.Thread(target=WaitForMessage, args=(s,)) th.start() message = input() s.sendall(message.encode('utf-8')) s.close()","title":"\u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0430\u044f \u0447\u0430\u0441\u0442\u044c"},{"location":"#_8","text":"\u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0438 \u043c\u0430\u0441\u0441\u043e\u0432\u043e\u0439 \u0440\u0430\u0441\u0441\u044b\u043b\u043a\u0438, \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0438 \u044d\u043c\u043e\u0434\u0437\u0438 \u0438 \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f: def Emojify(addr): emoji = b\"\\\\\" + f\"U0001F{addr % 1000}\".encode() return emoji.decode('unicode_escape') def SendToAll(msg): for i in clients: i.send(msg) def WaitForMessage(addr, conn): clients.append(conn) while True: try: data = conn.recv(1024) code = Emojify(addr[1]) message = f\"\\n[{addr[1]}] {code} says: {data.decode('utf-8')}\" SendToAll(message.encode('utf-8')) except: clients.remove(conn) SendToAll(f\"{code} Disconnected\".encode('utf-8')) break conn.close() \u041d\u0435\u043f\u043e\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0435\u043d\u043d\u043e \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043b\u0443\u043f: s.listen(10) while True: conn, addr = s.accept() print('Connected with ' + addr[0] + ':' + str(addr[1])) th = threading.Thread(target=WaitForMessage, args=(addr, conn)) th.start()","title":"\u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c"},{"location":"#5","text":"","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 5"},{"location":"#_9","text":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0438\u0437 \u043f\u0440\u043e\u0448\u043b\u043e\u0433\u043e \u0437\u0430\u0434\u0430\u043d\u0438\u044f, \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u043c \u0437\u0430\u0434\u0430\u043d\u0438\u044f\u043c \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0438 \u0441\u043e\u043a\u0435\u0442. \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0433\u043e \u043b\u0443\u043f\u0430 \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: header = b'POST /subject HTTP/1.1\\r\\nHost: localhost\\r\\nAccept: text/html\\r\\nContent-Type: application/json\\r\\n' # \u0442\u0435\u043c\u043f\u043b\u0435\u0439\u0442 message = 1 while message: th = threading.Thread(target=WaitForMessage, args=(s,)) th.start() key = input('\u0414\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430: ') # \u0436\u0434\u0435\u043c \u0432\u0432\u043e\u0434\u0430 \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0430 \u0438 \u043e\u0446\u0435\u043d\u043a\u0438 value = input('\u041e\u0446\u0435\u043d\u043a\u0430: ') son_of_j = json.dumps({key: value}) # \u0441\u043e\u0437\u0434\u0430\u0435\u043c json request = header + f\"Content-Length: {len(son_of_j)}\\r\\n\\r\\n\".encode() + json.dumps({key: value}).encode('utf-8') s.send(request) s.close()","title":"\u041a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0430\u044f \u0447\u0430\u0441\u0442\u044c"},{"location":"#_10","text":"\u041a\u043b\u0430\u0441\u0441 Response: class Response: def __init__(self, status, reason, headers=None, body=None): self.status = status self.reason = reason self.headers = headers self.body = body def return_string(self): return f\"{self.status} {self.reason} {self.body}\" \u041a\u043b\u0430\u0441\u0441 Request: class Request: def __init__(self, method, target, version, headers, rfile, conn): self.method = method self.target = target self.version = version self.headers = headers self.rfile = rfile self.conn = conn @property def path(self): return self.url.path @property @lru_cache(maxsize=None) def query(self): return parse_qs(self.url.query) @property @lru_cache(maxsize=None) def url(self): return urlparse(self.target) def body(self): size = self.headers.get('Content-Length') if not size: return None return self.rfile.read(size) \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0438 \u043e\u0431\u0441\u043b\u0443\u0436\u0438\u0432\u0430\u043d\u0438\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: class HTTPserver(): def __init__(self, host, port, server_name): self._host = host self._port = port self._server_name = server_name def init_socket(self): self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: self.socket.bind((self._host, self._port)) self.socket.listen(10) except socket.error as msg: print('Error Code : ' + str(msg[0]) + ' Message ' + msg[1]) def launch_server(self): self.init_socket() while True: conn, addr = self.socket.accept() print('Connected with ' + addr[0] + ':' + str(addr[1])) th = threading.Thread(target=self.serve_client, args=(conn,)) th.start() def serve_client(self, conn): while True: req = self.parse_request(conn) resp = self.handle_request(req) conn.send(resp.return_string().encode()) with open('AcademicPerformance.html') as html: conn.send(html.read().encode()) # sending html conn.close() \u041f\u0430\u0440\u0441\u0435\u0440\u044b (\u043c\u0435\u0442\u043e\u0434\u044b \u0432\u043d\u0443\u0442\u0440\u0438 \u043a\u043b\u0430\u0441\u0441\u0430 HTTPserver): def parse_request(self, conn): rfile = conn.makefile('rb') method, target, ver = self.parse_request_line(rfile) headers = self.parse_headers(rfile) return Request(method, target, ver, headers, rfile, conn) def parse_request_line(self, rfile): raw = rfile.readline(MAX_LINE + 1) if len(raw) > MAX_LINE: raise HTTPError(400, 'Bad request', 'Request line is too long') req_line = str(raw, 'iso-8859-1') print(req_line) words = req_line.split() if len(words) != 3: raise HTTPError(400, 'Bad request', 'Malformed request line') method, target, ver = words if ver != 'HTTP/1.1': raise HTTPError(505, 'HTTP Version Not Supported') return method, target, ver def parse_headers(self, rfile): headers = [] while True: line = rfile.readline(MAX_LINE + 1) if len(line) > MAX_LINE: raise HTTPError(494, 'Request header too large') if line in (b'\\r\\n', b'\\n', b''): break headers.append(line) if len(headers) > MAX_HEADERS: raise HTTPError(494, 'Too many headers') sheaders = b''.join(headers).decode('iso-8859-1') return Parser().parsestr(sheaders) def handle_request(self, req): # \u0440\u0435\u0448\u0430\u0435\u043c \u043a\u0442\u043e \u043f\u043e\u0441\u0442, \u043a\u0442\u043e \u0433\u0435\u0442 if req.path == '/subject' and req.method == 'POST': return self.handle_post(req) if req.path == '/subject' and req.method == 'GET': return self.handle_get(req) \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 JSON \u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435\u043c \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b: def handle_post(self, req): # \u0443\u0441\u043f\u043e\u043a\u0430\u0438\u0432\u0430\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f, \u0447\u0442\u043e \u043c\u044b \u0432\u0441\u0435 \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u043b\u0438 content_type = req.headers.get('Content-Type') accept = req.headers.get('Accept') if ('text/html' in accept) and ('application/json' in content_type): # \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 accept \u0438 content-type contentType = 'text/html; charset=utf-8' body = 'I can read your request' son_of_j = self.ExtractJson(req) try: self.CombineAndSave(son_of_j) except: return Response(500, 'Internal server error') else: return Response(406, 'Not Acceptable') body = body.encode('utf-8') headers = [('Content-Type', contentType), ('Content-Length', len(body))] return Response(200, 'OK', headers, body) def CombineAndSave(self, d): with open('data.json', mode='r', encoding='utf-8') as f: data = json.load(f) for i in d.keys(): # \u0441\u043e\u0432\u043c\u0435\u0449\u0430\u0435\u043c json \u0444\u0430\u0439\u043b\u044b data[i] = data.get(i, []) data[i].append(d[i]) with open('data.json', mode='w', encoding='utf-8') as f: # \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0438\u0442\u043e\u0433\u043e\u0432\u044b\u0439 json json.dump(data, f) data = json2html.convert(json=data) with open('AcademicPerformance.html', 'w') as htmlfile: # \u0441\u043e\u0437\u0434\u0430\u0435\u043c html \u0438\u0437 json htmlfile.write(str(data)) def ExtractJson(self, req): # \u0432\u044b\u0442\u0430\u0441\u043a\u0438\u0432\u0430\u0435\u043c \u043a\u043e\u043d\u0442\u0435\u043d\u0442 \u0438\u0437 \u0440\u0435\u043a\u0432\u0435\u0441\u0442\u0430 json_str = req.rfile.readline(int(req.headers.get('Content-Length'))) return json.loads(json_str) \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0438 \u0437\u0430\u043f\u0443\u0441\u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0430: a = HTTPserver('localhost', 8081, 'Server') a.launch_server()","title":"\u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c"}]}